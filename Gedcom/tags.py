#!/usr/bin/env python

import os.path, time

selfModified = os.path.getmtime(os.path.abspath(os.path.dirname(__file__)))
jsonModified = os.path.getmtime('tags.json')
headerModified = os.path.getmtime('_Generated/GCObjects_generated.h')

if selfModified < headerModified and jsonModified < headerModified:
	print 'selfModified: %s' % time.ctime(selfModified)
	print 'jsonModified: %s' % time.ctime(jsonModified)
	print 'headerModified: %s' % time.ctime(headerModified)
	print 'NOT GOING TO RUN; touch tags.json to force.'
	exit()

import json
from string import Template

specialClasses = [ #don't generate classes for these
	'GCTrailerEntity',
	'GCChangeInfoAttribute'
];

classList = set()

# Templates:
propertyT = Template('/// $doc\n@property (nonatomic) $type *$name;\n')

collectionAccessorsT = Template("""
- (NSMutableArray *)mutable$capName {
    return [self mutableArrayValueForKey:@"$name"];
}

- (NSUInteger)countOf$capName {
	return [_$name count];
}

- (id)objectIn${capName}AtIndex:(NSUInteger)index {
    return [_$name objectAtIndex:index];
}
 
- (void)insertObject:(GCProperty *)obj in${capName}AtIndex:(NSUInteger)index {
	NSParameterAssert([obj isKindOfClass:[$type class]]);
	
	[($selfClass *)[self.context.undoManager prepareWithInvocationTarget:self] removeObjectFrom${capName}AtIndex:index];
	[self.context.undoManager setActionName:@"Undo $name"]; //TODO
	
	if (obj.describedObject == self) {
		return;
	}
	if (obj.describedObject) {
		[obj.describedObject.mutableProperties removeObject:obj];
	}
	obj.describedObject = self;
    [_$name insertObject:obj atIndex:index];
}

- (void)removeObjectFrom${capName}AtIndex:(NSUInteger)index {
	[($selfClass *)[self.context.undoManager prepareWithInvocationTarget:self] insertObject:_$name[index] in${capName}AtIndex:index];
	[self.context.undoManager setActionName:@"Undo $name"]; //TODO
	
	((GCProperty *)_$name[index]).describedObject = nil;
	
    [_$name removeObjectAtIndex:index];
}
	""")

singleAccessorsT = Template("""
- (void)set$capName:(GCProperty *)obj
{
	[($selfClass *)[self.context.undoManager prepareWithInvocationTarget:self] set$capName:_$name];
	[self.context.undoManager setActionName:@"Undo $name"]; //TODO
	
	if (_$name) {
		obj.describedObject = nil;
	}
	
	if (obj.describedObject) {
		[obj.describedObject.mutableProperties removeObject:obj];
	}
	
	obj.describedObject = self;
	
	_$name = (id)obj;
}

- ($type *)$name
{
	return _$name;
}
""")

constructorDeclarationT = Template("""/** Initializes and returns a $name.

 $doc
 @return A new $name.
*/
+($returnType *)$name$extra""")

constructorBodyT = Template("""{
	return [[self alloc] init$extra];
}""")

headerFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "$superClass.h"

$forwardDeclarations

$classDefinition
""")

implementationFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "$className.h"

#import "GCObject_internal.h"
#import "GCContext_internal.h"
#import "GCProperty_internal.h"

$includeHeaders

$classImplementation
""")

classDefinitionT = Template("""/**
 $doc
*/
@interface $name : $superClass

// Methods:
$methods

// Properties:
$propertyDeclarations

@end
""")
classImplementationT = Template("""@implementation $name {
$ivars
}

// Methods:
$methods

// Properties:
$propertyImplementations

@end
""")
initT = Template("""- (id)init$extraDef
{
	self = [super _initWithType:@"$type"$extraImp];
	
	if (self) {
		// initialize ivars, if any:
$initProperties
	}
	
	return self;
}
""")

def classify(name, type):
	if type:
		return 'GC%s%s%s%s' % (name[0].upper(), name[1:], type[0].upper(), type[1:])
	else:
		return 'GC%s%s' % (name[0].upper(), name[1:])

def pluralize(s):
	if not tags.has_key(s):
		return '%ss' % s
	if tags[s].has_key('plural'):
		return tags[s]['plural']
	else:
		return '%ss' % s

forwardDeclarations = set()

def property(selfClass, key, type, doc, is_plural, is_required, is_property_group=False):
	name = pluralize(key) if is_plural else key
	ivar = None
	definition = ''
	implementation = ''
	if not is_property_group:
		forwardDeclarations.add(classify(key, type))
	if is_plural:
		if is_property_group:
			definition = propertyT.substitute(
				type='NSArray',
				name=name,
				doc=doc
			)
			implementation = '@dynamic %s;' % name
		else:
			definition = '%s%s' % (propertyT.substitute(
				type='NSArray',
				name=name,
				doc='. '.join([doc, classify(key, type)])
			), propertyT.substitute(
				type='NSMutableArray',
				name='mutable%s%s' % (name[0].upper(), name[1:]),
				doc='. '.join([doc, name])
			))
			implementation = collectionAccessorsT.substitute(
				selfClass=selfClass,
				name=name,
				capName='%s%s' % (name[0].upper(), name[1:]),
				type=classify(key, type)
			)
			ivar = 'NSMutableArray *_%s' % name
	else:
		definition = propertyT.substitute(
			type=classify(key, type),
			name=name,
			doc='. '.join([doc, ' NB: required property.' if is_required else ''])
		)
		implementation = singleAccessorsT.substitute(
			selfClass=selfClass,
			type=classify(key, type),
			name=name,
			capName='%s%s' % (name[0].upper(), name[1:])
		)
		ivar = '%s *_%s' % (classify(key, type), name)

	return definition, implementation, ivar

def constructors(key, type):
	cons = dict()
	if type == 'entity':
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='InContext:(GCContext *)context',
            doc='@param context The context in which to create the entity.'
		)] = constructorBodyT.substitute(
			objectType=tags[key]['objectType'],
			name=key,
			extra='InContext:context'
		)
	else:
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='',
			doc=''
		)] = constructorBodyT.substitute(
			objectType=tags[key]['objectType'],
			name=key,
			extra=''
		)
		if type == 'attribute':
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithValue:(GCValue *)value',
				doc='@param value The value as a GCValue object.'
			)] = constructorBodyT.substitute(
				objectType=tags[key]['objectType'],
				name=key,
				extra='WithValue:value'
			)
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithGedcomStringValue:(NSString *)value',
				doc='@param value The value as an NSString.'
			)] = constructorBodyT.substitute(
				objectType=tags[key]['objectType'],
				name=key,
				extra='WithGedcomStringValue:value'
			)
	return cons

f = open('tags.json')
tags = json.load(f)

def propagate(key):
	print 'PROPAGATING VALUES FOR "%s"' % key
	if not tags[key].has_key('validSubTags'):
		tags[key]['validSubTags'] = []
	for variant in tags[key]['variants']:
		if variant.has_key('groupName'):
			propagate(variant['groupName'])
			continue
		if not tags[variant['name']].has_key('validSubTags'):
			tags[variant['name']]['validSubTags'] = []
		tags[variant['name']]['validSubTags'].extend([x for x in tags[key]['validSubTags'] if x not in tags[variant['name']]['validSubTags']])
		if tags[key].has_key('objectType') and not tags[variant['name']].has_key('objectType'):
			tags[variant['name']]['objectType'] = tags[key]['objectType']

for key in sorted(tags):
	if key[0] == '@':
		propagate(key)

def expand_group(className, group, propertyDeclarations, propertyImplementations, ivars):
	dec, imp, ivar = property(className, group[1:], '', 'Property for accessing the following properties', True, False, is_property_group=True)
					
	propertyDeclarations.append(dec)
	propertyImplementations.append(imp)
	if ivar: ivars.append(ivar)
	
	for variant in tags[group]['variants']:
		if variant.has_key('groupName'):
			dec, imp, ivar = property(className, group[1:], '', 'Property for accessing the following properties', True, False, is_property_group=True)
			
			if dec not in propertyDeclarations:
				propertyDeclarations.append(dec)
				propertyImplementations.append(imp)
				if ivar: ivars.append(ivar)
			
			expand_group(className, variant['groupName'], propertyDeclarations, propertyImplementations, ivars)
			continue
		print '		PROCESSING VARIANT "%s": %s' % (variant['name'], tags[variant['name']])
		dec, imp, ivar = property(className, variant['name'], tags[variant['name']]['objectType'], 'Also contained in %ss. %s' % (group[1:], variant['doc'] if variant.has_key('doc') else ''), variant['max'] == 'M' or variant['max'] > 1, variant['min'] == 1)
		propertyDeclarations.append(dec)
		propertyImplementations.append(imp)
		if ivar: ivars.append(ivar)


for key in sorted(tags):
	print 'PROCESSING KEY "%s": %s' % (key, tags[key])
	if key[0] != '@':
		forwardDeclarations = set()
		classDefinitions = []
		classImplementations = []
		className = classify(key, tags[key]['objectType'])
		if not tags[key]['objectType'] in ['entity', 'attribute', 'relationship'] or className in specialClasses:
			print 'SKIPPING KEY "%s"' % key
			continue
		cons = constructors(key, tags[key]['objectType'])
		
		methodDefs = []
		methodImps = []
		
		for declaration in sorted(cons):
			methodDefs.append('%s;' % declaration)
			methodImps.append('%s\n%s' % (declaration, cons[declaration]))
		
		propertyDeclarations = []
		propertyImplementations = []
		ivars = []
		
		if tags[key].has_key('validSubTags'):
			for prop in tags[key]['validSubTags']:
				print '	PROCESSING SUBTAG %s' % prop
				if prop.has_key('groupName'):
					expand_group(className, prop['groupName'], propertyDeclarations, propertyImplementations, ivars)
					
				else:
					dec, imp, ivar = property(className, prop['name'], tags[prop['name']]['objectType'], prop['doc'] if prop.has_key('doc') else '', prop['max'] == 'M' or prop['max'] > 1, prop['min'] == 1)
					propertyDeclarations.append(dec)
					propertyImplementations.append(imp)
					if ivar: ivars.append(ivar)
		
		methodImps.append(initT.substitute(
			type=key,
			initProperties="\n".join(['\t\t%s = [NSMutableArray array];' % x[16:] for x in ivars if x[:14] == 'NSMutableArray']),
			extraDef='InContext:(GCContext *)context' if tags[key]['objectType'] == 'entity' else '',
			extraImp=' inContext:context' if tags[key]['objectType'] == 'entity' else ''
		))
		
		classDefinition = classDefinitionT.substitute(
			name=className,
			superClass=classify(tags[key]['objectType'], ''),
			doc=tags[key]['doc'] if tags[key].has_key('doc') else '',
			methods="\n".join(methodDefs),
			propertyDeclarations="\n".join(propertyDeclarations)
		)
		classImplementation = classImplementationT.substitute(
			name=className,
			methods="\n".join(methodImps),
			propertyImplementations="\n".join(propertyImplementations),
			ivars="\n".join(['\t%s;' % x for x in ivars])
		)
	
		h_file = open('_Generated/generated_headers/%s.h' % className, 'w')
		h_file.write(headerFileT.substitute(
			superClass=classify(tags[key]['objectType'], ''),
			forwardDeclarations="\n".join(sorted([("@class %s;" % x) for x in forwardDeclarations])),
			classDefinition=classDefinition
		))
		h_file.close()
		
		m_file = open('_Generated/generated_implementations/%s.m' % className, 'w')
		m_file.write(implementationFileT.substitute(
			className=className,
			includeHeaders="\n".join(sorted([('#import "%s.h"' % x) for x in forwardDeclarations])),
			classImplementation=classImplementation
		))
		m_file.close()
		
		classList.add(className)
	
	print 'DONE PROCESSING %s' % key

h_file = open('_Generated/GCObjects_generated.h', 'w')
for className in classList:
	h_file.write('#import "%s.h"\n' % className);
h_file.close()
