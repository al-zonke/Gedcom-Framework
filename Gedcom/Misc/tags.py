#!/usr/bin/env python

import sys, argparse
import json
from string import Template

specialClasses = [ #don't generate classes for these
	'GCTrailerEntity',
	'GCChangeInfoAttribute'
];

# Templates:
propertyT = Template('/// $doc\n@property (nonatomic) $type *$name;\n')

collectionAccessorsT = Template("""
- (NSMutableArray *)mutable$capName {
	return [self mutableArrayValueForKey:@"$name"];
}

- (NSUInteger)countOf$capName {
	return [_$name count];
}

- (id)objectIn${capName}AtIndex:(NSUInteger)index {
	return [_$name objectAtIndex:index];
}
 
- (void)insertObject:(id)obj in${capName}AtIndex:(NSUInteger)index {
	NSParameterAssert([obj isKindOfClass:[$type class]]);
	
	NSBundle *frameworkBundle = [NSBundle bundleForClass:[self class]];
	
	NSString *formatString = [frameworkBundle localizedStringForKey:@"Undo %@"
															  value:@"Undo %@"
															  table:@"Misc"];
	
	[($selfClass *)[self.undoManager prepareWithInvocationTarget:self] removeObjectFrom${capName}AtIndex:index];
	[self.undoManager setActionName:[NSString stringWithFormat:formatString, self.localizedType]];
	
	if ([obj valueForKey:@"describedObject"] == self) {
		return;
	}
	
	if ([obj valueForKey:@"describedObject"]) {
		[((GCObject *)[obj valueForKey:@"describedObject"]).mutableProperties removeObject:obj];
	}
	
	[obj setValue:self forKey:@"describedObject"];
	
	[_$name insertObject:obj atIndex:index];
}

- (void)removeObjectFrom${capName}AtIndex:(NSUInteger)index {
	NSBundle *frameworkBundle = [NSBundle bundleForClass:[self class]];
	
	NSString *formatString = [frameworkBundle localizedStringForKey:@"Undo %@"
															  value:@"Undo %@"
															  table:@"Misc"];
	
	[($selfClass *)[self.undoManager prepareWithInvocationTarget:self] insertObject:_$name[index] in${capName}AtIndex:index];
	[self.undoManager setActionName:[NSString stringWithFormat:formatString, self.localizedType]];
	
	[((GCObject *)_$name[index]) setValue:nil forKey:@"describedObject"];
	
	[_$name removeObjectAtIndex:index];
}
""")

constructorDeclarationT = Template("""/** Initializes and returns a $name.

 $doc
 @return A new $name.
*/
+($returnType *)$name$extra""")

constructorBodyT = Template("""{
	return [[self alloc] init$extra];
}""")

headerFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "$superClass.h"

$forwardDeclarations

$classDefinition
""")

implementationFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "$className.h"

#import "GCObject_internal.h"

$includeHeaders

$classImplementation
""")

classDefinitionT = Template("""/**
 $doc
*/
@interface $name : $superClass

// Methods:
$methods

// Properties:
$propertyDeclarations

@end
""")
classImplementationT = Template("""@implementation $name {
$ivars
}

// Methods:
$methods

// Properties:
$propertyImplementations

@end
""")
initT = Template("""- (id)init$extraDef
{
	self = [super _initWithType:@"$type"$extraImp];
	
	if (self) {
		// initialize ivars, if any:
$initProperties
	}
	
	return self;
}
""")

def classify(name, type):
	if type:
		return 'GC%s%s%s%s' % (name[0].upper(), name[1:], type[0].upper(), type[1:])
	else:
		return 'GC%s%s' % (name[0].upper(), name[1:])

def pluralize(s, tags):
	if not tags.has_key(s):
		return '%ss' % s
	if tags[s].has_key('plural'):
		return tags[s]['plural']
	else:
		return '%ss' % s

def property(tags, selfClass, key, type, doc, forwardDeclarations, is_plural, is_required, is_property_group=False):
	name = pluralize(key, tags) if is_plural else key
	ivar = None
	definition = ''
	implementation = ''
	if not is_property_group:
		forwardDeclarations.add(classify(key, type))
	if is_plural:
		if is_property_group:
			definition = propertyT.substitute(
				type='NSArray',
				name=name,
				doc=doc
			)
			implementation = '@dynamic %s;' % name
		else:
			definition = '%s%s' % (propertyT.substitute(
				type='NSArray',
				name=name,
				doc='. '.join([doc, classify(key, type)])
			), propertyT.substitute(
				type='NSMutableArray',
				name='mutable%s%s' % (name[0].upper(), name[1:]),
				doc='. '.join([doc, name])
			))
			implementation = collectionAccessorsT.substitute(
				selfClass=selfClass,
				name=name,
				capName='%s%s' % (name[0].upper(), name[1:]),
				type=classify(key, type)
			)
			ivar = 'NSMutableArray *_%s' % name
	else:
		definition = propertyT.substitute(
			type=classify(key, type),
			name=name,
			doc='. '.join([doc, ' NB: required property.' if is_required else ''])
		)
		implementation = '@dynamic %s;' % name
		ivar = '%s *_%s' % (classify(key, type), name)

	return definition, implementation, ivar

def constructors(key, type):
	cons = dict()
	if type == 'entity':
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='InContext:(GCContext *)context',
			doc='@param context The context in which to create the entity.'
		)] = constructorBodyT.substitute(
			objectType=type,
			name=key,
			extra='InContext:context'
		)
	else:
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='',
			doc=''
		)] = constructorBodyT.substitute(
			objectType=type,
			name=key,
			extra=''
		)
		if type == 'attribute':
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithValue:(GCValue *)value',
				doc='@param value The value as a GCValue object.'
			)] = constructorBodyT.substitute(
				objectType=type,
				name=key,
				extra='WithValue:value'
			)
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithGedcomStringValue:(NSString *)value',
				doc='@param value The value as an NSString.'
			)] = constructorBodyT.substitute(
				objectType=type,
				name=key,
				extra='WithGedcomStringValue:value'
			)
	return cons

def expand_group(tags, className, group, propertyDeclarations, propertyImplementations, ivars, forwardDeclarations):
	dec, imp, ivar = property(tags, className, group[1:], '', 'Property for accessing the following properties', forwardDeclarations, True, False, is_property_group=True)
					
	propertyDeclarations.append(dec)
	propertyImplementations.append(imp)
	if ivar: ivars.append(ivar)
	
	for variant in tags[group]['variants']:
		if variant.has_key('groupName'):
			dec, imp, ivar = property(tags, className, group[1:], '', 'Property for accessing the following properties', forwardDeclarations, True, False, is_property_group=True)
			
			if dec not in propertyDeclarations:
				propertyDeclarations.append(dec)
				propertyImplementations.append(imp)
				if ivar: ivars.append(ivar)
			
			expand_group(tags, className, variant['groupName'], propertyDeclarations, propertyImplementations, ivars, forwardDeclarations)
			continue
		print >> sys.stderr, '		PROCESSING VARIANT "%s": %s' % (variant['name'], tags[variant['name']])
		dec, imp, ivar = property(tags, className, variant['name'], tags[variant['name']]['objectType'], 'Also contained in %ss. %s' % (group[1:], variant['doc'] if variant.has_key('doc') else ''), forwardDeclarations, variant['max'] == 'M' or variant['max'] > 1, variant['min'] == 1)
		propertyDeclarations.append(dec)
		propertyImplementations.append(imp)
		if ivar: ivars.append(ivar)

def process(key, tags):
	print >> sys.stderr, 'PROCESSING KEY "%s": %s' % (key, tags[key])
	if key[0] != '@':
		forwardDeclarations = set()
		classDefinitions = []
		classImplementations = []
		className = classify(key, tags[key]['objectType'])
		if not tags[key]['objectType'] in ['entity', 'attribute', 'relationship'] or className in specialClasses:
			print >> sys.stderr, 'SKIPPING KEY "%s"' % key
			return
		cons = constructors(key, tags[key]['objectType'])
		
		methodDefs = []
		methodImps = []
		
		for declaration in sorted(cons):
			methodDefs.append('%s;' % declaration)
			methodImps.append('%s\n%s' % (declaration, cons[declaration]))
		
		propertyDeclarations = []
		propertyImplementations = []
		ivars = []
		
		if tags[key].has_key('validSubTags'):
			for prop in tags[key]['validSubTags']:
				print >> sys.stderr, '	PROCESSING SUBTAG %s' % prop
				if prop.has_key('groupName'):
					expand_group(tags, className, prop['groupName'], propertyDeclarations, propertyImplementations, ivars, forwardDeclarations)
					
				else:
					dec, imp, ivar = property(tags, className, prop['name'], tags[prop['name']]['objectType'], prop['doc'] if prop.has_key('doc') else '', forwardDeclarations, prop['max'] == 'M' or prop['max'] > 1, prop['min'] == 1)
					propertyDeclarations.append(dec)
					propertyImplementations.append(imp)
					if ivar: ivars.append(ivar)
		
		methodImps.append(initT.substitute(
			type=key,
			initProperties="\n".join(['\t\t%s = [NSMutableArray array];' % x[16:] for x in ivars if x[:14] == 'NSMutableArray']),
			extraDef='InContext:(GCContext *)context' if tags[key]['objectType'] == 'entity' else '',
			extraImp=' inContext:context' if tags[key]['objectType'] == 'entity' else ''
		))
		
		classDefinition = classDefinitionT.substitute(
			name=className,
			superClass=classify(tags[key]['objectType'], ''),
			doc=tags[key]['doc'] if tags[key].has_key('doc') else '',
			methods="\n".join(methodDefs),
			propertyDeclarations="\n".join(propertyDeclarations)
		)
		classImplementation = classImplementationT.substitute(
			name=className,
			methods="\n".join(methodImps),
			propertyImplementations="\n".join(propertyImplementations),
			ivars="\n".join(['\t%s;' % x for x in ivars])
		)
		
		superClass = classify(tags[key]['objectType'], '')
		h_file = open('Gedcom/_Generated/generated_headers/%s.h' % className, 'w')
		h_file.write(headerFileT.substitute(
			superClass=superClass if not tags[key]['objectType'] == 'entity' else ('%s_internal' % superClass),
			forwardDeclarations="\n".join(sorted([("@class %s;" % x) for x in forwardDeclarations])),
			classDefinition=classDefinition
		))
		h_file.close()
		
		m_file = open('Gedcom/_Generated/generated_implementations/%s.m' % className, 'w')
		m_file.write(implementationFileT.substitute(
			className=className,
			includeHeaders="\n".join(sorted([('#import "%s.h"' % x) for x in forwardDeclarations])),
			classImplementation=classImplementation
		))
		m_file.close()
		
		print >> sys.stderr, 'DONE PROCESSING %s' % key

def uniq(seq):
	seen = set()
	seen_add = seen.add
	return [ x for x in seq if x not in seen and not seen_add(x)]

def propagate(variantKey, sourceDict, tagInfo):
	print >> sys.stderr, 'PROPAGATING VALUES FOR "%s"' % variantKey
	print >> sys.stderr, sourceDict
	
	variantDict = tagInfo[variantKey]
	
	if not variantDict.has_key('validSubTags'):
		variantDict['validSubTags'] = []
	
	print >> sys.stderr, variantDict['validSubTags']
	
	if sourceDict.has_key('validSubTags'):
		variantDict['validSubTags'].extend([x for x in sourceDict['validSubTags'] if x not in variantDict['validSubTags']])
	
	if sourceDict.has_key('valueType') and not variantDict.has_key('valueType'):
		variantDict['valueType'] = sourceDict['valueType']
	if sourceDict.has_key('objectType') and not variantDict.has_key('objectType'):
		variantDict['objectType'] = sourceDict['objectType']
	if sourceDict.has_key('allowsNil') and not variantDict.has_key('allowsNil'):
		variantDict['allowsNil'] = sourceDict['allowsNil']
		
	print >> sys.stderr, tagInfo[variantKey]

def setupKey(key, tagInfo, done):
	if key in done:
		return
	
	done.add(key)
	
	classList = set()
	
	tagDict = tagInfo[key]
	
	# name
	tagDict['name'] = key[1:] if key[0] == '@' else key
	
	# pluralName
	if not tagDict.has_key('plural'):
		tagDict['plural'] = '%ss' % tagDict['name']
	
	# allowsNil
	if not tagDict.has_key('allowsNil'):
		tagDict['allowsNil'] = False
	
	if not key[0] == '@':
		tagDict['className'] = classify(key, tagDict['objectType'])
	
	print >> sys.stderr, 'PROCESSING KEY "%s": %s' % (key, tagInfo[key])
	
	# propagate info to variants
	if tagDict.has_key('variants'):
		for variant in tagDict['variants']:
			if variant.has_key('groupName'):
				for subVariant in tagInfo[variant['groupName']]['variants']:
					propagate(subVariant['name'], tagDict, tagInfo)
					
					setupKey(subVariant['name'], tagInfo, done)
			elif variant.has_key('name'):
				propagate(variant['name'], tagDict, tagInfo)
				
				setupKey(variant['name'], tagInfo, done)
	
	# set up subtags
	if tagDict.has_key('validSubTags'):
		for subTag in tagDict['validSubTags']:
			if subTag.has_key('groupName'):
				setupKey(subTag['groupName'], tagInfo, done);
			else:
				setupKey(subTag['name'], tagInfo, done);
	
	process(key, tagInfo)
	
	return done


if __name__=='__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument("input_path", help="path to tags.json")
	args = parser.parse_args()
	
	f = open(args.input_path)
	tagDicts = json.load(f)
	
	tags = setupKey('@rootObject', tagDicts, set())
	
	h_file = open('Gedcom/_Generated/GCObjects_generated.h', 'w')
	for key in tags:
		if tagDicts[key].has_key('className') and tagDicts[key]['className'] not in specialClasses:
			h_file.write('#import "%s.h"\n' % tagDicts[key]['className']);
	h_file.close()
	
	print >> sys.stderr, 'DUMPING JSON'
	
	print json.dumps(tagDicts)
