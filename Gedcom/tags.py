#!/usr/bin/env python

import os.path, time

selfModified = os.path.getmtime(os.path.abspath(os.path.dirname(__file__)))
jsonModified = os.path.getmtime('tags.json')
headerModified = os.path.getmtime('GCObjects_generated.h')

if selfModified < headerModified and jsonModified < headerModified:
	print 'selfModified: %s' % time.ctime(selfModified)
	print 'jsonModified: %s' % time.ctime(jsonModified)
	print 'headerModified: %s' % time.ctime(headerModified)
	print 'NOT GOING TO RUN; touch tags.json to force.'
	exit()

import json
from string import Template

specialClasses = [ #don't generate classes for these
	'GCTrailerEntity',
	'GCChangeInfoAttribute'
];

# Templates:
forwardT = Template('@class $name;')

propertyT = Template('/// $doc\n@property (nonatomic) $type *$name;\n')
dynamicT = Template('@dynamic $name;')

mutableAccessorsT = Template("""
- (NSMutableArray *)mutable$capName {
    return [self mutableArrayValueForKey:@"$name"];
}

- (id)objectIn${capName}AtIndex:(NSUInteger)index {
    return [_$name objectAtIndex:index];
}
 
- (NSArray *)${name}AtIndexes:(NSIndexSet *)indexes {
    return [_$name objectsAtIndexes:indexes];
}

- (void)insertObject:($type *)obj in${capName}AtIndex:(NSUInteger)index {
	NSParameterAssert([obj isKindOfClass:[$type class]]);
	obj.describedObject = self;
    [_$name insertObject:obj atIndex:index];
}

- (void)removeObjectFrom${capName}AtIndex:(NSUInteger)index {
	(($type *)_$name[index]).describedObject = nil;
    [_$name removeObjectAtIndex:index];
}
""")

constructorDeclarationT = Template("""/** Initializes and returns a $name.

 $doc
 @return A new $name.
*/
+($returnType *)$name$extra""")

constructorBodyT = Template("""{
	return [[self alloc] init$extra];
}""")

headerFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "GCEntity.h"
#import "GCAttribute.h"
#import "GCRelationship.h"

#pragma mark Forward declarations

$forwardDeclarations

#pragma mark Class definitions

$classDefinitions
""")

implementationFileT = Template("""/*
 This file was autogenerated by tags.py 
 */

#import "GCObjects_generated.h"

#import "GCObject_internal.h"
#import "GCProperty_internal.h"

$classImplementations
""")

classDefinitionT = Template("""/**
 $doc
*/
@interface $name : $superClass

// Methods:
$methods

// Properties:
$propertyDeclarations

@end
""")
classImplementationT = Template("""@implementation $name {
$ivars
}

// Methods:
$methods

// Properties:
$propertyImplementations

@end
""")
initT = Template("""- (id)init$extraDef
{
	self = [super _initWithType:@"$type"$extraImp];
	
	if (self) {
		// initialize ivars, if any:
$initProperties
	}
	
	return self;
}
""")

def classify(name, type):
	if type:
		return 'GC%s%s%s%s' % (name[0].upper(), name[1:], type[0].upper(), type[1:])
	else:
		return 'GC%s%s' % (name[0].upper(), name[1:])

def pluralize(s):
	if not tags.has_key(s):
		return '%ss' % s
	if tags[s].has_key('plural'):
		return tags[s]['plural']
	else:
		return '%ss' % s

forwardDeclarations = set()

def property(key, type, doc, is_plural, is_required, is_property_group=False):
	name = pluralize(key) if is_plural else key
	ivar = None
	definition = ''
	implementation = ''
	if is_plural:
		if is_property_group:
			definition = propertyT.substitute(
				type='NSArray',
				name=name,
				doc=doc
			)
			implementation = dynamicT.substitute(name=name)
		else:
			definition = '%s%s' % (propertyT.substitute(
				type='NSArray',
				name=name,
				doc='. '.join([doc, classify(key, type)])
			), propertyT.substitute(
				type='NSMutableArray',
				name='mutable%s%s' % (name[0].upper(), name[1:]),
				doc='. '.join([doc, name])
			))
			implementation = mutableAccessorsT.substitute(
				name=name,
				capName='%s%s' % (name[0].upper(), name[1:]),
				type=classify(key, type)
			)
			ivar = '_%s' % name
	else:
		forwardDeclarations.add(forwardT.substitute(name=classify(key, type)))
		definition = propertyT.substitute(
			type=classify(key, type),
			name=name,
			doc='. '.join([doc, ' NB: required property.' if is_required else ''])
		)

	return definition, implementation, ivar

def constructors(key, type):
	cons = dict()
	if type == 'entity':
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='InContext:(GCContext *)context',
            doc='@param context The context in which to create the entity.'
		)] = constructorBodyT.substitute(
			objectType=tags[key]['objectType'],
			name=key,
			extra='InContext:context'
		)
	else:
		cons[constructorDeclarationT.substitute(
			returnType=classify(key, type),
			name=key, 
			extra='',
			doc=''
		)] = constructorBodyT.substitute(
			objectType=tags[key]['objectType'],
			name=key,
			extra=''
		)
		if type == 'attribute':
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithValue:(GCValue *)value',
				doc='@param value The value as a GCValue object.'
			)] = constructorBodyT.substitute(
				objectType=tags[key]['objectType'],
				name=key,
				extra='WithValue:value'
			)
			cons[constructorDeclarationT.substitute(
				returnType=classify(key, type),
				name=key, 
				extra='WithGedcomStringValue:(NSString *)value',
				doc='@param value The value as an NSString.'
			)] = constructorBodyT.substitute(
				objectType=tags[key]['objectType'],
				name=key,
				extra='WithGedcomStringValue:value'
			)
	return cons

f = open('tags.json')
tags = json.load(f)

classDefinitions = []
classImplementations = []

def propagate(key):
	print 'PROPAGATING VALUES FOR "%s"' % key
	if not tags[key].has_key('validSubTags'):
		tags[key]['validSubTags'] = []
	for variant in tags[key]['variants']:
		if variant.has_key('groupName'):
			propagate(variant['groupName'])
			continue
		if not tags[variant['name']].has_key('validSubTags'):
			tags[variant['name']]['validSubTags'] = []
		tags[variant['name']]['validSubTags'].extend([x for x in tags[key]['validSubTags'] if x not in tags[variant['name']]['validSubTags']])
		if tags[key].has_key('objectType') and not tags[variant['name']].has_key('objectType'):
			tags[variant['name']]['objectType'] = tags[key]['objectType']

for key in sorted(tags):
	if key[0] == '@':
		propagate(key)

def expand_group(group, propertyDeclarations, propertyImplementations, ivars):
	dec, imp, ivar = property(group[1:], '', 'Property for accessing the following properties', True, False, is_property_group=True)
					
	propertyDeclarations.append(dec)
	propertyImplementations.append(imp)
	if ivar: ivars.append(ivar)
	
	for variant in tags[group]['variants']:
		if variant.has_key('groupName'):
			dec, imp, ivar = property(group[1:], '', 'Property for accessing the following properties', True, False, is_property_group=True)
			
			if dec not in propertyDeclarations:
				propertyDeclarations.append(dec)
				propertyImplementations.append(imp)
				if ivar: ivars.append(ivar)
			
			expand_group(variant['groupName'], propertyDeclarations, propertyImplementations, ivars)
			continue
		print '		PROCESSING VARIANT "%s": %s' % (variant['name'], tags[variant['name']])
		dec, imp, ivar = property(variant['name'], tags[variant['name']]['objectType'], 'Also contained in %ss. %s' % (group[1:], variant['doc'] if variant.has_key('doc') else ''), variant['max'] == 'M' or variant['max'] > 1, variant['min'] == 1)
		propertyDeclarations.append(dec)
		propertyImplementations.append(imp)
		if ivar: ivars.append(ivar)


for key in sorted(tags):
	print 'PROCESSING KEY "%s": %s' % (key, tags[key])
	if key[0] != '@':
		if not tags[key]['objectType'] in ['entity', 'attribute', 'relationship'] or classify(key, tags[key]['objectType']) in specialClasses:
			print 'SKIPPING KEY "%s"' % key
			continue
		cons = constructors(key, tags[key]['objectType'])
		
		methodDefs = []
		methodImps = []
		
		for declaration in sorted(cons):
			methodDefs.append('%s;' % declaration)
			methodImps.append('%s\n%s' % (declaration, cons[declaration]))
		
		propertyDeclarations = []
		propertyImplementations = []
		ivars = []
		
		if tags[key].has_key('validSubTags'):
			for prop in tags[key]['validSubTags']:
				print '	PROCESSING SUBTAG %s' % prop
				if prop.has_key('groupName'):
					expand_group(prop['groupName'], propertyDeclarations, propertyImplementations, ivars)
					
				else:
					dec, imp, ivar = property(prop['name'], tags[prop['name']]['objectType'], prop['doc'] if prop.has_key('doc') else '', prop['max'] == 'M' or prop['max'] > 1, prop['min'] == 1)
					propertyDeclarations.append(dec)
					propertyImplementations.append(imp)
					if ivar: ivars.append(ivar)
		
		methodImps.append(initT.substitute(
			type=key,
			initProperties="\n".join(['\t\t%s = [NSMutableArray array];' % x for x in ivars]),
			extraDef='InContext:(GCContext *)context' if tags[key]['objectType'] == 'entity' else '',
			extraImp=' inContext:context' if tags[key]['objectType'] == 'entity' else ''
		))
		
		classDefinitions.append(classDefinitionT.substitute(
			name=classify(key, tags[key]['objectType']),
			superClass=classify(tags[key]['objectType'], ''),
			doc=tags[key]['doc'] if tags[key].has_key('doc') else '',
			methods="\n".join(methodDefs),
			propertyDeclarations="\n".join(propertyDeclarations)
		))
		classImplementations.append(classImplementationT.substitute(
			name=classify(key, tags[key]['objectType']),
			methods="\n".join(methodImps),
			propertyImplementations="\n".join(propertyImplementations),
			ivars="\n".join(['\tNSMutableArray *%s;' % x for x in ivars])
		))
	
	print 'DONE PROCESSING %s' % key

h_file = open('GCObjects_generated.h', 'w')
h_file.write(headerFileT.substitute(
	forwardDeclarations="\n".join(sorted(forwardDeclarations)),
	classDefinitions="\n".join(classDefinitions)
))
h_file.close()

m_file = open('GCObjects_generated.m', 'w')
m_file.write(implementationFileT.substitute(
	classImplementations="\n".join(classImplementations)
))
m_file.close()